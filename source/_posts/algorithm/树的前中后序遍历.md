---
title: 树的前中后序遍历
tags: algorithm
comment: true
date: 2019-10-02 12:09:00
description: 以Leetcode94，144，145为例，介绍了在面试中经常出现的树遍历的基本操作。
---
每一个遍历都用了两种方法，recursive(递归)和iteratively(用栈)
## Leetcode94:Binary Tree Inorder Traversal
### 题目描述
Given a binary tree, return the inorder traversal of its nodes' values.
Example:
Input: [1,null,2,3]
```
   1
    \
     2
    /
   3
```
Output: [1,3,2]
Follow up: Recursive solution is trivial, could you do it iteratively?
### 解
#### python code[20ms 11.7MB]
用递归
```
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root==None:
            return []
        left = self.inorderTraversal(root.left)
        right = self.inorderTraversal(root.right)
        return left+[root.val]+right
```
#### c++ code[0ms 8.7MB]
用栈，一开始的做法改node了，因为不然会死循环，虽然这个右节点的左节点被访问过了，但是没有record,下次还会再访问，所以就把访问过的左节点改成空。狠毒如我。
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> s;
        vector<int> res;
        TreeNode* tmp;
        if(!root) return res;
        s.push(root);
        while (!s.empty())
        {
            root = s.top();
            while (root->left)
            {
                s.push(root->left);
                tmp = root;
                root = root->left;
                tmp->left=nullptr;
            }
            res.push_back(root->val);
            s.pop();
            if(root->right!=nullptr) s.push(root->right);
        }
        return res;
    }
};
```
不改node的做法呢，是在每次while开头访问top的时候，让这个top的所有左节点都已经被访问过了。
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        std::stack<TreeNode *> s;
        vector<int> res;
        while (root) {
            s.push(root);
            root = root->left;
        }
        while (!s.empty()) {
            TreeNode *node = s.top();
            s.pop();
            res.push_back(node->val);

            node = node->right;
            while (node) {
                s.push(node);
                node = node->left;
            }
        }
        return res;
    }
};
```
## Leetcode144:Binary Tree Preorder Traversal
### 题目描述
Given a binary tree, return the preorder traversal of its nodes' values.
Example:
Input: [1,null,2,3]
```
   1
    \
     2
    /
   3
```
Output: [1,2,3]
Follow up: Recursive solution is trivial, could you do it iteratively?
### 解
#### python code[16ms 11.9MB]
用递归，python用递归解决这种是真的方便又简洁啊
```
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root==None:
            return []
        return [root.val]+self.preorderTraversal(root.left)+self.preorderTraversal(root.right)
```
#### c++ code[4ms 9.2MB]
前序比较简单咯，碰见了就直接push back就行了
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> s;
        if (root==nullptr) return res;
        s.push(root);
        while (!s.empty())
        {
            root = s.top();
            s.pop();
            res.push_back(root->val);
            if(root->right) s.push(root->right);
            if(root->left) s.push(root->left);
        }
        return res;
    }
};
```
## Leetcode145:Binary Tree Postorder Traversal
### 题目描述
Given a binary tree, return the postorder traversal of its nodes' values.
Example:
Input: [1,null,2,3]
```
   1
    \
     2
    /
   3
```
Output: [3,2,1]
Follow up: Recursive solution is trivial, could you do it iteratively?
### 解
#### python code[28ms 11.8MB]
递归
```
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root==None:
            return []
        return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val]
```
#### c++ code[4ms 9.1MB]
和中序差不多，但是在把当前root->val放进result之前要判断一下root->right是否访问过
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> s;
        if(root==nullptr) return res;
        s.push(root);
        while (root->left)
        {
            s.push(root->left);
            root = root->left;
        }
        while (!s.empty())
        {
            root = s.top();
            if(root->right){
                if(res.empty()||res[res.size()-1]!=root->right->val){
                    TreeNode* tmp=root->right;
                    while (tmp)
                    {
                        s.push(tmp);
                        tmp = tmp->left;
                    }
                }
                else{
                    res.push_back(root->val);
                    s.pop();
                }
            }
            else{
                res.push_back(root->val);
                s.pop();
            }
        }
        return res;
    }
};
```
