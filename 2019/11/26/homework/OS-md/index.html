<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="os,">










<meta name="description" content="参考之前学长学姐的整理，2019年中国科学院大学杨力祥老师操作系统课程思考题整理。">
<meta name="keywords" content="os">
<meta property="og:type" content="article">
<meta property="og:title" content="国科大2019操作系统思考题整理">
<meta property="og:url" content="https://wegnery219.github.io/2019/11/26/homework/OS-md/index.html">
<meta property="og:site_name" content="Ning Ning">
<meta property="og:description" content="参考之前学长学姐的整理，2019年中国科学院大学杨力祥老师操作系统课程思考题整理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190120113031555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NTAwNDkz,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2020-05-18T02:52:34.208Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="国科大2019操作系统思考题整理">
<meta name="twitter:description" content="参考之前学长学姐的整理，2019年中国科学院大学杨力祥老师操作系统课程思考题整理。">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190120113031555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NTAwNDkz,size_16,color_FFFFFF,t_70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://wegnery219.github.io/2019/11/26/homework/OS-md/">





  <title>国科大2019操作系统思考题整理 | Ning Ning</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ning Ning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">投己所好</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://wegnery219.github.io/2019/11/26/homework/OS-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ning Ning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">国科大2019操作系统思考题整理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-26T16:11:07+00:00">
                2019-11-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  参考之前学长学姐的整理，2019年中国科学院大学杨力祥老师操作系统课程思考题整理。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这份整理是基于中国科学院大学杨力祥老师的操作系统课程的思考题整理。考试形式为开卷，基本都从这里出题。整理过程中大部分参考了之前学长学姐的博客：<a href="https://blog.csdn.net/qq_27500493/article/details/86560421" target="_blank" rel="noopener">https://blog.csdn.net/qq_27500493/article/details/86560421</a>,并感谢杨晨同学友情校正并且在我复习的时候无私解答，祝他以后走到哪都有4g信号。<br>关于杨老师的课，想多说几句，是我开学以来觉得选的最值的一门课，上课不划水，直接讲linux内核源代码，从开机加电到第一个进程的创建，第一次觉得操作系统整体架构这么清晰。老师本人上课的时候也在一直强调体系性思维，在他的课里面也有很好的体现，不像本科的操原课东讲一点西讲一点考试考的跟文科一样(没错我就是要踩一捧一)。这门课的考试也非常简单，建议以后即将来国科大的计算机专业学弟学妹们，选它！选它！选它！两学分轻松到手！课后无作业！上课讲的好！考试不刁难！还在等什么！选它！不要盲目从众选一些跟ai有关的课，人多，而且学不到什么真正的东西。每次去都挤得要死下课除了记得自己睡着了啥也不记得。<br>整理中的页码对应的是这本书，建议购买正版，因为老师会给你签名<br><img src="https://img-blog.csdnimg.cn/20190120113031555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NTAwNDkz,size_16,color_FFFFFF,t_70" alt="image"><br>注：所有带*号的为2019年思考题中未出现的题目</p>
<h2 id="第一章-从开机加电到main函数执行之前"><a href="#第一章-从开机加电到main函数执行之前" class="headerlink" title="第一章 从开机加电到main函数执行之前"></a>第一章 从开机加电到main函数执行之前</h2><p>1.为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？<br>最开始启动计算机的时候，计算机内存未初始化，没有任何程序。而因为CPU只能读取内存中的程序，所以必须将操作系统先加载进内存当中。需要使用BIOS。在加电后， BIOS 需要完成一些检测工作，设置实模式下的中断向量表和服务程序，并将操作系统的引导扇区加载至 0x7C00 处，然后将跳转至 0x7C00运行操作系统自身的代码。所以计算机启动最开始运行的是BIOS代码。</p>
<p>2，为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载的扇区都加载？<br>BIOS和操作系统的开发通常是不同的团队，按固定的规则约定，可以进行灵活的各自设计相应的部分。BIOS接到启动操作系统命令后，只从启动扇区将代码加载至0x7c00(BOOTSEG)位置，而后续扇区由bootsect代码加载，这些代码由编写系统的用户负责，与之前BIOS无关。这样构建的好处是站在整个体系的高度，统一设计和统一安排，简单而有效。</p>
<p>如果要使用BIOS进行加载，而且加载完成之后再执行，则需要很长的时间，因此Linux采用的是边执行边加载的方法。</p>
<p>3，为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？<br>加载0x07c00是BIOS提前约定设置的，不能加载到0x00000是因为从0x00000开始到0x003ff这1KB内存空间都是BIOS首先约定进行加载中断向量表的地方，不能进行覆盖。</p>
<p>而后挪到0x90000处是操作系统开始根据自己的需要安排内存了，具体原因如下：</p>
<p>① 内核会使用启动扇区中的一些数据，如第 508、509 字节处的 ROOT_DEV；</p>
<p>② 依据系统对内存的规划，内核占用 0x00000 开始的空间，因此 0x07c00 可能会被覆盖。</p>
<p>4，bootsect、setup、head程序之间是怎么衔接的？给出代码证据。<br>① bootsect跳转到setup程序：jmpi 0,SETUPSEG; P15</p>
<p>bootsect首先利用int 0x13中断分别加载setup程序及system模块，待bootsect程序的任务完成之后，执行代码jmpi 0,SETUPSEG。由于 bootsect 将 setup 段加载到了 SETUPSEG:0 （0x90200）的地方,在实模式下，CS:IP指向setup程序的第一条指令，此时setup开始执行。</p>
<p>② setup跳转到head程序：jmpi 0,8 P26</p>
<p>执行setup后，内核被移到了0x00000处，CPU变为保护模式，执行jmpi 0,8</p>
<p>并加载了中断描述符表和全局描述符表。该指令执行后跳转到以GDT第2项中的 base_addr 为基地址，以0为偏移量的位置，其中base_addr为0。由于head放置在内核的头部，因此程序跳转到head中执行。</p>
<p>5，setup程序里的cli是为了什么？P16<br>setup中cli之后的代码即将进行实模式下中断向量表和保护模式下中断描述符表(IDT)的交接工作。如果没有cli，又恰好发生中断，就要面对实模式的中断机制已经废除，保护模式的中断机制尚未完善的局面，系统会崩溃。cli保证了idt完整创建，避免不可预料中断的进入造成idt创建不完整或新老中断机制混用。</p>
<p>6，setup程序的最后是jmpi 0,8 为什么这个8不能简单的当作阿拉伯数字8看待？P26<br>此时为32位保护模式，“0”表示段内偏移，“8”表示段选择符。转化为二进制：1000</p>
<p>最后两位00表示内核特权级，第三位0表示 GDT 表，第四位1表示根据GDT中的第2项来确定代码段的段基址和段限长等信息。可以得到代码是从head 的开始位置，段基址 0x00000000、偏移为 0 处开始执行的。</p>
<p>7，打开A20和打开pe究竟是什么关系，保护模式不就是32位的吗？为什么还要打开A20？有必要吗？P35,41<br>A20如果没打开，则计算机处于20位寻址模式，pe只是一个flag，代表目前处于保护模式，如果pe打开了a20没打开，计算机还是20位寻址，超过20位的会回滚，不是真正的32位寻址。<br>有必要。</p>
<p>A20是CPU的第 21 位地址线，A20 未打开的时候，实模式下的最大寻址为 1MB+64KB,而第21根地址线被强制为0，所以相当于CPU“回滚”到内存地址起始处寻址。打开A20仅仅意味着CPU可以进行32位寻址，且最大寻址空间是4GB，而打开PE是使能保护模式。打开A20是打开PE的必要条件；而打开A20不一定非得打开PE。打开PE是说明系统处于保护模式下，如果不打开A20的话，A20 会被强制置 0，则保护模式下访问的内存是不连续的，如 0<del>1M,2</del>3M,4~5M 等，若要真正在保护模式下工作，必须打开A20，实现32位寻址。</p>
<p>8，在setup程序里曾经设置过一次gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么折腾两次，而不是一次搞好？P33<br>原来setup中的gdt会被后来的缓冲区覆盖掉，又无法通过复制解决问题。如果先复制GDT再移动system，会被后者覆盖，如果先移动system后复制gdt，又回把head.s对应的程序覆盖，此时head.s还没有执行。</p>
<p>9，Linux是用C语言写的，为什么没有从main开始，而是先运行3个汇编程序，道理何在？P43<br>c语言编写的用户程序需要在操作系统的平台上执行，要由操作系统为应用程序创建进程。操作系统由3个汇编程序加载。<br>main 函数运行在 32 位的保护模式下，但系统启动时默认为 16 位的实模式，开机时的 16 位实模式与 main 函数执行需要的 32 位保护模式之间有很大的差距，这个差距需要由 3 个汇编程序来填补。其中 bootsect 负责加载， setup 与 head 则负责获取硬件参数，准备 idt,gdt,开启 A20， PE,PG，废弃旧的 16 位中断响应机制，建立新的 32 为 IDT，设置分页机制等。这些工作做完后，计算机处在32 位的保护模式状态下时，调用main的条件才算准备完毕。</p>
<p>10，为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。P42<br>如果用call调用main，ret的时候不知道返回给谁，不存在一个更底层的系统程序接收操作系统的返回，采用了仿call操作。相当于替换了原始栈中的EIP的值为入口地址_main<br>[答案on csdn：CALL 指令会将 EIP 的值自动压栈，保护返回现场，然后执行被调函数，当执行到被调函数的ret指令时，自动出栈给 EIP 并还原现场，继续执行CALL 的下一行指令。在由head程序向main函数跳转时，不需main函数返回；且因为main函数是最底层的函数，无更底层的函数进行返回。因此要达到既调用 main又不需返回，选择ret。]</p>
<p>下面三题参考IA-32-3中文版.pdf<br>11，保护模式的“保护”体现在哪里？<br>保护操作系统的安全，不受到恶意攻击。保护进程地址空间。</p>
<p>“保护”体现在：</p>
<p>打开保护模式后，CPU 的寻址模式发生了变化，基于 GDT 去获取代码或数据段的基址，相当于增加了一个段位寄存器。防止了对代码或数据段的覆盖以及代码段自身的访问超限。对描述符所描述的对象进行保护：在 GDT、 LDT 及 IDT 中，均有对应界限、特权级等；在不同特权级间访问时，系统会对 CPL、 RPL、 DPL、 IOPL 等进行检验，同时限制某些特殊指令如 lgdt, lidt,cli 等的使用；分页机制中 PDE 和 PTE 中的 R/W 和 U/S 等提供了页级保护，分页机制通过将线性地址与物理地址的映射，提供了对物理地址的保护。</p>
<p>12，特权级的目的和意义是什么？为什么特权级是基于段的？<br>特权级机制目的是为了进行合理的管理资源，保护高特权级的段。</p>
<p>意义是进行了对系统的保护，对操作系统的“主奴机制”影响深远。Intel 从硬件上禁止低特权级代码段使用部分关键性指令，通过特权级的设置禁止用户进程使用 cli、 sti 等指令。将内核设计成最高特权级，用户进程成为最低特权级。这样，操作系统可以访问 GDT、 LDT、 TR，而 GDT、 LDT 是逻辑地址形成线性地址的关键，因此操作系统可以掌控线性地址。物理地址是由内核将线性地址转换而成的，所以操作系统可以访问任何物理地址。而用户进程只能使用逻辑地址。总之，特权级的引入对操作系统内核进行保护。</p>
<p>通过段，系统划分了内核代码段、内核数据段、用户代码段和用户数据段等不同的数据段，有些段是系统专享的，有些是和用户程序共享的，因此就有特权级的概念。</p>
<p>13*.保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？p438-440 </p>
<p>（1） 保护模式在“保护”什么？它的“保护”体现在哪里？</p>
<p>保护操作系统的安全，不受到恶意攻击。保护进程地址空间。</p>
<p>“保护”体现在</p>
<p>打开保护模式后，CPU 的寻址模式发生了变化，基于 GDT 去获取代码或数据段的基址，相当于增加了一个段位寄存器。防止了对代码或数据段的覆盖以及代码段自身的访问超限。对描述符所描述的对象进行保护：在 GDT、 LDT 及 IDT 中，均有对应界限、特权级等；在不同特权级间访问时，系统会对 CPL、 RPL、 DPL、 IOPL 等进行检验，同时限制某些特殊指令如 lgdt, lidt,cli 等的使用；分页机制中 PDE 和 PTE 中的 R/W 和 U/S 等提供了页级保护，分页机制通过将线性地址与物理地址的映射，提供了对物理地址的保护。</p>
<p>（2）特权级的目的和意义是什么？</p>
<p>特权级机制目的是为了进行合理的管理资源，保护高特权级的段。</p>
<p>意义是进行了对系统的保护，对操作系统的“主奴机制”影响深远。Intel 从硬件上禁止低特权级代码段使用部分关键性指令，通过特权级的设置禁止用户进程使用 cli、 sti 等指令。将内核设计成最高特权级，用户进程成为最低特权级。这样，操作系统可以访问 GDT、 LDT、 TR，而 GDT、 LDT 是逻辑地址形成线性地址的关键，因此操作系统可以掌控线性地址。物理地址是由内核将线性地址转换而成的，所以操作系统可以访问任何物理地址。而用户进程只能使用逻辑地址。总之，特权级的引入对操作系统内核进行保护。</p>
<p>（3）分页有“保护”作用吗？</p>
<p>分页机制有保护作用，使得用户进程不能直接访问内核地址，进程间也不能相互访问。用户进程只能使用逻辑地址，而逻辑地址通过内核转化为线性地址，根据内核提供的专门为进程设计的分页方案，由MMU非直接映射转化为实际物理地址形成保护。此外，通过分页机制，每个进程都有自己的专属页表，有利于更安全、高效的使用内存，保护每个进程的地址空间。</p>
<p>为什么特权级是基于段的？（超纲备用）</p>
<p>通过段，系统划分了内核代码段、内核数据段、用户代码段和用户数据段等不同的数据段，有些段是系统专享的，有些是和用户程序共享的，因此就有特权级的概念。</p>
<p>14*.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。P37-39<br>如何分页<br>head.s在setup_paging开始创建分页机制。将页目录表和4个页表放到物理内存的起始位置，从内存起始位置开始的5个页空间内容全部清零（每页4KB），然后设置页目录表的前4项，使之分别指向4个页表。然后开始从高地址向低地址方向填写4个页表，依次指向内存从高地址向低地址方向的各个页面。即将第4个页表的最后一项指向寻址范围的最后一个页面。即从0xFFF000开始的4kb 大小的内存空间。将第4个页表的倒数第二个页表项指向倒数第二个页面，即0xFFF000-0x1000开始的4KB字节的内存空间，依此类推。<br>挂接关系图<br>代码证据</p>
<p>P39最下面</p>
<p>15*.在head程序执行结束的时候，在idt的前面有184个字节的head程序的剩余代码，剩余了什么？为什么要剩余？P40<br>剩余代码：</p>
<p>包含代码段如下after_page_tables(栈中压入了些参数)、 ignore_int(初始化中断时的中断处理函数) 和 setup_paging(初始化分页)。</p>
<p>剩余的原因：</p>
<p>after_page_tables 中压入的参数，为内核进入 main 函数的跳转做准备。设计者在栈中压入了 L6: main，以使得系统出错时，返回到 L6 处执行。</p>
<p>ignore_int 为中断处理函数，使用 ignore_int 将 idt 全部初始化，如果中断开启后存在使用了未设置的中断向量，那么将默认跳转到 ignore_int 处执行，使得系统不会跳转到随机的地方执行错误的代码。</p>
<p>setup_paging 进行初始化分页，在该函数中对 0x0000 和 0x5000 的进行了初始化操作。该代码用于跳转到 main，即执行“ret”指令。</p>
<p>16*.进程0的task_struct在哪？具体内容是什么？<br>进程0的task_struct位于内核数据区，因为在进程0未激活之前，使用的是boot阶段的user_stack，因此存储在user_stack中。</p>
<p>具体内容如下：</p>
<p>包含了进程 0 的进程状态、进程 0 的 LDT、进程 0 的 TSS 等等。其中 ldt 设置了代码段和堆栈段的基址和限长(640KB)，而 TSS 则保存了各种寄存器的值，包括各个段选择符。</p>
<p>代码如下：(若未要求没时间可不写)</p>
<p>INIT_TASK的定义见P68。</p>
<p>17*.用文字和图说明中断描述符表是如何初始化的，可以举例说明（比如：set_trap_gate(0,&amp;divide_error)），并给出代码证据。<br>（先画图见P54 图2-9然后解释）以set_trap_gate(0,&amp;divide_error)为例，其中，n是0，gate_addr是&amp;idt[0]，也就是idt的第一项中断描述符的地址；type是15，dpl（描述符特权级）是0；addr是中断服务程序divide_error(void)的入口地址。</p>
<p>代码证据：P53 代码</p>
<h2 id="第二章：设备环境初始化及激活进程0"><a href="#第二章：设备环境初始化及激活进程0" class="headerlink" title="第二章：设备环境初始化及激活进程0"></a>第二章：设备环境初始化及激活进程0</h2><p>1、进程0的task_struct、内核栈、用户栈在哪？证明进程0的用户栈就是未激活进程0时的0特权栈，即user_stack，而进程0的内核栈并不是user_stack，给出代码证据。<br>进程0的task_struct和内核栈共用一个task_union，即init_task，init_task在内核的数据区</p>
<p>进程0的用户栈就是user_stack，也在内核的数据区。首先在kernel/sched.c中，将stack_start设置为{&amp;user_stack[PAGE_SIZE &gt;&gt; 2], 0x10}，在head.S中lss _stack_start, %esp将ss:esp设置内核数据段的user_stack的尾端地址，从这里到move_to_user_mode的movl %esp, %eax, pushl %eax的过程中，ss和esp的内容没有发生变化，在iret之后，进程0的ss和esp指向的就是user_stack的最末端。</p>
<p>进程0的内核栈不是user_stack的代码证据：<br>在创建进程0的task_struct，即INIT_TASK的时候，将ss0设置为0x10，esp0为PAGE_SIZE + long(&amp;init_task)，ss0和esp0指向的位置即为内核栈，并不是user_stack，而且是init_task的尾端。</p>
<p>2、在system.h里</p>
<p>#define <em>set_gate(gate_addr,type,dpl,addr) <br><em>_asm</em></em> (“movw %%dx,%%ax\n\t” <br>    “movw %0,%%dx\n\t” <br>    “movl %%eax,%1\n\t” <br>    “movl %%edx,%2” <br>    : <br>    : “i” ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), <br>    “o” (<em>((char *) (gate_addr))), <br>    “o” (</em>(4+(char *) (gate_addr))), <br>    “d” ((char *) (addr)),”a” (0x00080000))</p>
<p>#define set_intr_gate(n,addr) <br>    _set_gate(&amp;idt[n],14,0,addr)</p>
<p>#define set_trap_gate(n,addr) <br>    _set_gate(&amp;idt[n],15,0,addr)</p>
<p>#define set_system_gate(n,addr) <br>    _set_gate(&amp;idt[n],15,3,addr)<br>这里中断门、陷阱门、系统调用都是通过_set_gate设置的，用的是同一个嵌入汇编代码，比较明显的差别是dpl一个是3，另外两个是0，这是为什么？说明理由。<br>当用户程序产生系统调用软中断后， 系统都通过system_call总入口找到具体的系统调用函数。 set_system_gate设置系统调用，须将 DPL设置为 3，允许在用户特权级（3）的进程调用，否则会引发 General Protection 异常。set_trap_gate 及 set_intr_gate 设置陷阱和中断为内核使用，需禁止用户进程调用，所以 DPL为 0。</p>
<p>3、进程0 fork进程1之前，为什么先要调用move_to_user_mode()？用的是什么方法？解释其中的道理。P79<br>Linux操作系统规定，除进程 0 之外， 所有进程都是由一个已有进程在用户态下完成创建的。需要将进程0通过调用move_to_user_mode()从内核态转换为用户态。进程0从0特权级到3特权级转换时采用的是模仿中断返回。</p>
<p>设计者通过代码模拟 int（中断） 压栈， 当执行 iret 指令时， CPU 将SS,ESP,EFLAGS,CS,EIP 5 个寄存器的值按序恢复给 CPU， CPU之后翻转到 3 特权级去执行代码。</p>
<p>4、在IA-32中，有大约20多个指令是只能在0特权级下使用，其他的指令，比如cli，并没有这个约定。奇怪的是，在Linux0.11中，在3特权级的进程代码并不能使用cli指令，会报特权级错误，这是为什么？请解释并给出代码证据。<br>根据Intel Manual，cli和sti指令与CPL和EFLAGS[IOPL]有关。通过IOPL来加以保护指令in,ins,out,outs,cli,sti等I/O敏感指令，只有CPL(当前特权级)&lt;=IOPL才能执行，低特权级访问这些指令将会产生一个一般性保护异常。P68<br>IOPL位于EFLAGS的12-13位，仅可通过iret来改变，INIT_TASK中IOPL为0，在move_to_user_mode中直接执行“pushfl \n\t”指令，继承了内核的EFLAGS。IOPL的指令仍然为0没有改变，所以用户进程无法调用cli指令。因此，通过设置 IOPL， 3特权级的进程代码不能使用 cli 等I/O敏感指令。</p>
<p>具体代码：move_to_user_mode()此处一共两部分代码第一部分 P79</p>
<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define move_to_user_mode() \</span><br><span class="line"></span><br><span class="line">__asm__(“movl <span class="variable">%%</span>esp, <span class="variable">%%</span>eax<span class="symbol">\n</span><span class="symbol">\t</span>” \</span><br><span class="line"></span><br><span class="line">                   ……</span><br><span class="line"></span><br><span class="line">                   “pushfl<span class="symbol">\n</span><span class="symbol">\t</span>” <span class="symbol">\ </span>                              // ELAGS 进栈</span><br><span class="line"></span><br><span class="line">                   ……</span><br><span class="line"></span><br><span class="line">”)</span><br></pre></td></tr></table></figure>

<p>第二部分代码见P 68 INIT_TASK</p>
<p>5、用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？P259<br>不可行<br>GDT和LDT放在内核数据区，属于0特权级，3特权级的用户进程无权访问修改。此外，如果用户进程可以自己设计LDT的话，表明用户进程可以访问其他进程的LDT，则会削弱进程之间的保护边界，容易引发问题。<br>p259书上有详细说明，抄就完事了</p>
<p>6、分析初始化IDT、GDT、LDT的代码。P54,66<br>IDT: set_trap_gate(n, addr)  _set_gate(gate_addr,type,dpl,addr)P54<br>（先画图见P54 图2-9然后解释）以set_trap_gate(0,&amp;divide_error)为例，其中，n是0，gate_addr是&amp;idt[0]，也就是idt的第一项中断描述符的地址；type是15，dpl（描述符特权级）是0；addr是中断服务程序divide_error(void)的入口地址。</p>
<p>代码证据：P53 代码</p>
<p>GDT:  p=gdt+2+FIRST_TSS_ENTRY //从GDT的六项，即TSS1开始向上全部清0</p>
<p>LDT:set_ldt_sec(gdt+FIRST_LDT_ENTRY, &amp;init_task.task.ldt) //设置ldt0<br>lldt(0); //将ldt挂接到ldtr寄存器</p>
<p>7、在sched_init(void)函数中有这样的代码：<br>for(i=1;i&lt;NR_TASKS;i++) {<br>    task[i] = NULL;<br>    ……<br>但并未涉及task[0]，从后续代码能感觉到已经给了进程0，请给出代码证据。<br>struct task_struct * task[NR_TASKS]={&amp;(init_task.task), };<br>而static union task_union init_task={INIT_TASK,} //进程0的task struct<br>相当于初始化task[NR_TASKS]的第一项为进程0</p>
<p>8*.在Linux操作系统中大量使用了中断、异常类的处理，究竟有什么好处？<br>采用以“被动模式” 代替“主动轮询” 模式来处理终端问题。进程在主机中运算需用到 CPU，其中可能进行“异常处理” ，此时需要具体的服务程序来执行。 这种中断服务体系的建立是为了被动响应中断信号。因此， CPU 就可以更高效的处理用户程序服务， 不用考虑随机可能产生的中断信号，从而提高了操作系统的综合效率</p>
<h2 id="第三章I-进程0创建进程1及调度"><a href="#第三章I-进程0创建进程1及调度" class="headerlink" title="第三章I:进程0创建进程1及调度"></a>第三章I:进程0创建进程1及调度</h2><p>补充：用户态/内核态，用户栈/内核栈<br>一、用户态和内核态<br>    内核态和用户态是操作系统的两种运行级别，用于区分不同程序的不同权利。</p>
<pre><code>内核态就是拥有资源多的状态，或者说访问资源多的状态，也称为特权态。相对来说，用户态就是非特权态，访问的而资源将受到限制。如果一个程序运行在特权态，该程序就可以访问计算机的任何资源，它的资源访问权限不受限制。如果一个程序运行在用户态，其资源需求将受到各种限制。如：要访问操作系统的内核数据结构，如进程表，则需要在特选态下才能办到。如果要访问用户程序里的数据，在用户态即可。</code></pre><p>二、用户栈和内核栈<br>    内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的栈。每一个进程都有两个栈，一个用户栈，存在于用户空间；一个内核栈，存在于内核空间。当进程在用户空间运行时，CPU栈指针寄存器里面的内容都是用户栈地址，使用用户栈；当进程在内核空间时，CPU栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。</p>
<pre><code>当进程因为中断或者系统调用陷入到内核态时，进程所使用的栈也要从用户栈转到内核栈。进程陷入到内核态后，先把用户栈的地址保存在内核栈之中，然后设置栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；当进程从内核态恢复到用户态之后时，在内核态之后的最后将保存在内核栈里面的用户栈的地址恢复到栈指针寄存器即可。这样就实现了用户栈和内核栈的互转。

那么，知道从内核转到用户态时，用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，如何知道内核栈的地址？关键在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为当进程在用户态运行时，使用的用户栈，当进程陷入到内核态时，内核保存进程在内核态运行的相关信息，但是一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给栈指针寄存器就可以了。</code></pre><p>1、进程0 fork进程1之前，为什么先调用move_to_user_mode()？用的是什么方法？解释其中的道理。(第二章也留过这个思考题 P79,80)<br>Linux操作系统规定，除进程 0 之外， 所有进程都是由一个已有进程在用户态下完成创建的。需要将进程0通过调用move_to_user_mode()从内核态转换为用户态。进程0从0特权级到3特权级转换时采用的是模仿中断返回。</p>
<p>设计者通过代码模拟 int（中断） 压栈， 当执行 iret 指令时， CPU 将SS,ESP,EFLAGS,CS,EIP 5 个寄存器的值按序恢复给 CPU， CPU之后翻转到 3 特权级去执行代码。</p>
<p>2、为什么static inline _syscall0(type,name)中加上关键字inline？P104<br>inline一般是用于定义内联函数，内联函数结合了函数以及宏的优点，在定义时和函数一样，编译器会对其参数进行检查；在使用时和宏类似，内联函数的代码会被直接嵌入在它被调用的地方，这样省去了函数调用时的一些额外开销，比如保存和恢复函数返回地址等，可以加快速度。前面fork的时候压了一次栈，这里也是系统调用，也要压栈，用inline节省时间</p>
<p>上面这个答案也不是不行，但是我觉得下面这个原因重要一点：</p>
<p>进程0和进程1共用一个用户栈，所以进程0不能把用户栈搞乱，否则进程1的fork()返回值就不对了<br>如果你有《Linux内核完全注释》的话，可以找一下这个函数的注释，linus在注释里面说明了原因。</p>
<p>3、copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。 　p79<br>执行int 0x80系统中断的时候cpu设计的是会自动压栈。<br>在 fork()中， 当执行“int $0x80” 时产生一个软中断， 使 CPU 硬件自动将 SS、 ESP、EFLAGS、 CS、 EIP 这 5 个寄存器的数值按这个顺序压入进程 0 的内核栈。 硬件压栈可确保 eip 的值指向正确的指令， 使中断返回后程序能继续执行。因为通过栈进行函数传递参数，所以恰可做为 copy_process 的最后五项参数。</p>
<p>4、打开保护模式、分页后，线性地址到物理地址是如何转换的？p97<br>CR3记录页目录表项的物理地址，通过CR3和线性地址的22-31位找到页表地址，通过页表地址和线性地址的12-21位找到页的地址，通过页的地址和第0-11位业内偏移落实到实际的物理地址值。</p>
<p>5、分析get_free_page()函数的代码，叙述在主内存中获取一个空闲页的技术路线。p89<br>通过逆向扫描页表位图 mem_map， 并由第一空页的下标左移 12 位加 LOW_MEM 得到该页的物理地址， 位于 16M 内存末端。P89代码考试不用看</p>
<p>过程：</p>
<p>① 将EAX 设置为0,EDI 设置指向mem_map 的最后一项（mem_map+PAGING_PAGES-1），std设置扫描是从高地址向低地址。从mem_map的最后一项反向扫描，找出引用次数为0(AL)的页，如果没有则退出；如果找到，则将找到的页设引用数为1；</p>
<p>② ECX左移12位得到页的相对地址，加LOW_MEM得到物理地址，将此页最后一个字节的地址赋值给EDI（LOW_MEM+4092）；</p>
<p>③ stosl将EAX的值设置到ES:EDI所指内存，即反向清零1024*32bit，将此页清空；</p>
<p>④ 将页的地址（存放在EAX）返回。</p>
<p>6、分析copy_page_tables（）函数的代码，叙述父进程如何为子进程复制页表。p97<br>from_dir代表爹，to_dir代表儿子，size代表一共是几个页表，两重for循环，第一重过页目录项，第二重过页表，如果爹是进程0，只copy前160个，如果不是，copy1024项。<br>官方：进入copy_page_tables()后，先为新的页表申请一个空闲页面，并把进程0中的第一个页表里面前160个页表项复制到这个页面中，进程0和进程1的页表暂时都指向了相同的页面，之后对进程1的页目录表进行设置，最后用重置cr3的方法刷新页变换高速缓存。</p>
<p>7、进程0创建进程1时，为进程1建立了task_struct及内核栈，第一个页表，分别位于物理内存16MB顶端倒数第一页、第二页。请问，这两个页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间？说明理由（可以图示）并给出代码证据。P264,283<br>P274,p283有答案<br>均占用内核的线性地址空间， 原因如下：<br>通过逆向扫描页表位图，并由第一空页的下标左移 12 位加 LOW_MEM 得到该页的物理地址，位于 16M 内存末端。 代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_free_page</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __<span class="function">res <span class="title">asm</span><span class="params">(<span class="string">"ax"</span>)</span></span>;</span><br><span class="line">__asm__(<span class="string">"std ; repne ; scasb\n\t"</span></span><br><span class="line"><span class="string">"jne 1f\n\t"</span></span><br><span class="line"><span class="string">"movb $1,1(%%edi)\n\t"</span></span><br><span class="line"><span class="string">"sall $12,%%ecx\n\t"</span></span><br><span class="line"><span class="string">"addl %2,%%ecx\n\t"</span></span><br><span class="line"><span class="string">"movl %%ecx,%%edx\n\t"</span></span><br><span class="line"><span class="string">"movl $1024,%%ecx\n\t"</span></span><br><span class="line"><span class="string">"leal 4092(%%edx),%%edi\n\t"</span></span><br><span class="line"><span class="string">"rep ; stosl\n\t"</span></span><br><span class="line"><span class="string">" movl %%edx,%%eax\n"</span></span><br><span class="line"><span class="string">"1: cld"</span></span><br><span class="line">:<span class="string">"=a"</span> (__res)</span><br><span class="line">:<span class="string">"0"</span> (<span class="number">0</span>),<span class="string">"i"</span> (LOW_MEM),<span class="string">"c"</span> (PAGING_PAGES),</span><br><span class="line"><span class="string">"D"</span> (mem_map+PAGING_PAGES<span class="number">-1</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程 0 和进程 1 的 LDT 的 LIMIT 属性将进程 0 和进程 1 的地址空间限定0~640KB， 所以进程 0、 进程 1 均无法访问到这两个页面， 故两页面占用内核的线性地址空间。进程 0 的局部描述符如下</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include/linux/sched.h: INIT_TASK</span><br><span class="line"><span class="comment">/* ldt */</span> &#123;<span class="number">0x9f</span>,<span class="number">0xc0fa00</span>&#125;, \</span><br><span class="line">&#123;<span class="number">0x9f</span>,<span class="number">0xc0f200</span>&#125;, \</span><br><span class="line">内核线性地址等于物理地址(<span class="number">0x00000</span>~<span class="number">0xfffff</span>)， 挂接操作的代码如下(head.s/setup_paging)：</span><br><span class="line">movl $pg0+<span class="number">7</span>,pg_dir <span class="comment">/* set present bit/user r/w */</span></span><br><span class="line">movl $pg1+<span class="number">7</span>,pg_dir+<span class="number">4</span> <span class="comment">/* --------- " " --------- */</span></span><br><span class="line">movl $pg2+<span class="number">7</span>,pg_dir+<span class="number">8</span> <span class="comment">/* --------- " " --------- */</span></span><br><span class="line">movl $pg3+<span class="number">7</span>,pg_dir+<span class="number">12</span> <span class="comment">/* --------- " " --------- */</span></span><br><span class="line">movl $pg3+<span class="number">4092</span>,%edi</span><br><span class="line">movl $0xfff007,%eax <span class="comment">/* 16Mb - 4096 + 7 (r/w user,p) */</span></span><br><span class="line">std</span><br><span class="line"><span class="number">1</span>: stosl <span class="comment">/* fill pages backwards - more efficient :-) */</span></span><br><span class="line">subl $0x1000,%eax</span><br><span class="line">jge <span class="number">1</span>b</span><br></pre></td></tr></table></figure>

<p>8、根据代码详细分析，进程0如何根据调度第一次切换到进程1的。p103-107<br>① 进程0通过fork函数创建进程1，使其处在就绪态。</p>
<p>② 进程0调用pause函数。pause函数通过int 0x80中断，映射到sys_pause函数，将自身设为可中断等待状态，调用schedule函数。</p>
<p>③ schedule函数分析到当前有必要进行进程调度，第一次遍历进程，只要地址指针不为为空，就要针对处理。第二次遍历所有进程，比较进程的状态和时间片，找出处在就绪态且counter最大的进程，此时只有进程0和1，且进程0是可中断等待状态，只有进程1是就绪态，所以切换到进程1去执行。</p>
<p>9、switch_to(n)代码中的”ljmp %0\n\t” 很奇怪，按理说jmp指令跳转到得位置应该是一条指令的地址，可是这行代码却跳到了”m” (*&amp;__tmp.a)，这明明是一个数据的地址，更奇怪的，这行代码竟然能正确执行。请论述其中的道理。p107，279-280<br>其中a对应EIP，b对应CS，ljmp此时通过CPU中的电路进行硬件切换，进程由当前进程切换到进程n。CPU将当前寄存器的值保存到当前进程的TSS中，将进程n的TSS数据及LDT的代码段和数据段描述符恢复给CPU的各个寄存器，实现任务切换。</p>
<p>10、进程0开始创建进程1，调用fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，执行fork代码后，跳过init（）直接执行了for(;;) pause()，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看到向转向fork的goto语句，也没有看到循环语句，是什么原因导致fork反复执行？请说明理由（可以图示），并给出代码证据。P103<br>第一次fork()的值是1，见P101的return last_pid；，然后执行到for(;;) pause();执行到syscall0，到sys_pause() p105，<br>我不会，啥时候第二次执行fork了<br>主要涉及的代码位置如下：</p>
<p>Init/main.c 代码中P103 —— if 判断</p>
<p>Include/unistd.h 中P102 —— fork函数代码</p>
<p>进程1 TSS赋值，特别是 eip，eax 赋值</p>
<p>copy_process:</p>
<p>p-&gt;pid = last_pid;</p>
<p>…</p>
<p>p-&gt;tss.eip = eip;</p>
<p>p-&gt;tss.eflags = eflags;</p>
<p>p-&gt;tss.eax = 0;</p>
<p>…</p>
<p>p-&gt;tss.esp = esp;</p>
<p>…</p>
<p>p-&gt;tss.cs = cs &amp; 0xffff;</p>
<p>p-&gt;tss.ss = ss &amp; 0xffff;</p>
<p>…</p>
<p>p-&gt;state = TASK_RUNNING;</p>
<p>return last_pid;</p>
<p>原因</p>
<p>fork 为 inline 函数，其中调用了 sys_call0，产生 0x80 中断，将 ss, esp, eflags, cs, eip 压栈，其中 eip 为 int 0x80 的下一句的地址。在 copy_process 中，内核将进程 0 的 tss 复制得到进程 1 的 tss，并将进程 1 的 tss.eax 设为 0，而进程 0 中的 eax 为 1。在进程调度时 tss 中的值被恢复至相应寄存器中，包括 eip， eax 等。所以中断返回后，进程 0 和进程 1 均会从 int  0x80 的下一句开始执行，即 fork 执行了两次。</p>
<p>由于 eax 代表返回值，所以进程 0 和进程 1 会得到不同的返回值，在fork返回到进程0后，进程0判断返回值非 0，因此执行代码for(;;) pause();</p>
<p>在sys_pause函数中，内核设置了进程0的状态为 TASK_INTERRUPTIBLE，并进行进程调度。由于只有进程1处于就绪态，因此调度执行进程1的指令。由于进程1在TSS中设置了eip等寄存器的值，因此从 int 0x80 的下一条指令开始执行，且设定返回 eax 的值作为 fork 的返回值（值为 0），因此进程1执行了 init 的 函数。导致反复执行，主要是利用了两个系统调用 sys_fork 和 sys_pause 对进程状态的设置，以及利用了进程调度机制。<br>进程0 和进程1都执行了一次fork()，我记得网上的答案还行？</p>
<p>11、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）</p>
<ol>
<li>进程中有就绪进程，且时间片没有用完。</li>
</ol>
<p>正常情况下，schedule()函数首先扫描任务数组。通过比较每个就绪（TASK_RUNNING）任务的运行时间递减滴答计数counter 的值来确定当前哪个进程运行的时间最少。哪一个的值大，就表示运行时间还不长，于是就选中该进程，最后调用switch_to()执行实际的进程切换操作</p>
<ol start="2">
<li>进程中有就绪进程，但所有就绪进程时间片都用完（c=0）</li>
</ol>
<p>如果此时所有处于TASK_RUNNING 状态进程的时间片都已经用完，系统就会根据每个进程的优先权值priority，对系统中所有进程（包括正在睡眠的进程）重新计算每个任务需要运行的时间片值counter。计算的公式是：</p>
<p>counter = counter + priority/2</p>
<p>然后 schdeule()函数重新扫描任务数组中所有处于TASK_RUNNING 状态，重复上述过程，直到选择出一个进程为止。最后调用switch_to()执行实际的进程切换操作。</p>
<ol start="3">
<li>所有进程都不是就绪的c=-1</li>
</ol>
<p>此时代码中的c=-1，next=0，跳出循环后，执行switch_to(0)，切换到进程0执行，因此所有进程都不是就绪的时候进程0执行。</p>
<p>12*.假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。P274,275<br>内核的线性地址空间，图见P275</p>
<p>13*、根据代码详细说明copy_process函数的所有参数是如何形成的？P89<br>long eip, long cs, long eflags, long esp, long ss；这五个参数是中断使CPU自动压栈的。</p>
<p>long ebx, long ecx, long edx, long fs, long es, long ds为__system_call压进栈的参数。</p>
<p>long none 为<strong>system_call调用</strong>sys_fork压进栈EIP的值。</p>
<p>Int nr, long ebp, long edi, long esi, long gs,为__system_call压进栈的值。</p>
<p>额外注释：</p>
<p>一般在应用程序中，一个函数的参数是由函数定义的，而在操作系统底层中，函数参数可以由函数定义以外的程序通过压栈的方式“做”出来。copy_process函数的所有参数正是通过压栈形成的。代码见P83页、P85页、P86页。</p>
<p>14*、进程0创建进程1时调用copy_process函数，在其中直接、间接调用了两次get_free_page函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。P89,98<br>第一次调用get_free_page函数申请的空闲页面用于进程1 的task_struct及内核栈。首先将申请到的页面清0，然后复制进程0的task_struct，再针对进程1作个性化设置，其中esp0 的设置，意味着设置该页末尾为进程 1 的堆栈的起始地址。代码见P90 及 P92。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">kenel/fork.c:copy_process</span></span><br><span class="line"></span><br><span class="line">p = (struct task_struct *)get_free_page();</span><br><span class="line"></span><br><span class="line">*p = *current</span><br><span class="line"></span><br><span class="line">p-&gt;tss.esp0 = PAGE_SIZE + (long)p;</span><br></pre></td></tr></table></figure>

<p>第二次调用get_free_page函数申请的空闲页面用于进程1的页表。在创建进程1执行copy_process中，执行copy_mem(nr,p)时，内核为进程1拷贝了进程 0的页表（160 项），同时修改了页表项的属性为只读。代码见P98。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mm/memory.c</span>: copy_page_table</span><br><span class="line"></span><br><span class="line">if(!(to_page_table = (unsigned long *)get_free_page()))</span><br><span class="line"></span><br><span class="line">         return -1;</span><br><span class="line"></span><br><span class="line">*to_dir = ((unsigned long)to_page_table) | 7;</span><br></pre></td></tr></table></figure>

<p>15*、为什么get_free_page（）将新分配的页面清0？P265</p>
<p>答：</p>
<p>因为无法预知这页内存的用途，如果用作页表，不清零就有垃圾值，就是隐患。</p>
<p>答2：Linux在回收页面时并没有将页面清0，只是将mem_map中与该页对应的位置0。在使用get_free_page申请页时，也是遍历mem_map寻找对应位为0的页，但是该页可能存在垃圾数据，如果不清0的话，若将该页用做页表，则可能导致错误的映射，引发错误，所以要将新分配的页面清0。</p>
<p>16*、内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？P283<br>为新进程创建页表时，调用get_free_page()申请空页面，申请页面时，程序是在内核中执行的，处于内核的线性地址空间内，此时申请的页面早已映射到内核的线性地址空间内，内核因此具有访问它的能力。</p>
<p>17<em>、copy_mem（）和copy_page_tables（）在第一次调用时是如何运行的？P281 282<br>copy_mem()的第一次调用是进程0创建进程1时，它先提取当前进程（进程0）的代码段、数据段的段限长，并将当前进程（进程0）的段限长赋值给子进程（进程1）的段限长。然后提取当前进程（进程0）的代码段、数据段的段基址，检查当前进程（进程0）的段基址、段限长是否有问题。接着设置子进程（进程1）的LDT段描述符中代码段和数据段的基地址为nr(1)</em>64MB。最后调用copy_page_table()函数</p>
<p>copy_page_table()的参数是源地址、目的地址和大小，首先检测源地址和目的地址是否都是4MB的整数倍，如不是则报错，不符合分页要求。然后取源地址和目的地址所对应的页目录项地址，检测如目的地址所对应的页目录表项已被使用则报错，其中源地址不一定是连续使用的，所以有不存在的跳过。接着，取源地址的页表地址，并为目的地址申请一个新页作为子进程的页表，且修改为已使用。然后，判断是否源地址为0，即父进程是否为进程0 ，如果是，则复制页表项数为160，否则为1k。最后将源页表项复制给目的页表，其中将目的页表项内的页设为“只读”，源页表项内的页地址超过1M的部分也设为”只读”（由于是第一次调用，所以父进程是0，都在1M内，所以都不设为“只读”），并在mem_map中所对应的项引用计数加1。1M内的内核区不参与用户分页管理。</p>
<h2 id="第三章II-进程的执行"><a href="#第三章II-进程的执行" class="headerlink" title="第三章II:进程的执行"></a>第三章II:进程的执行</h2><p>1、为什么要设计缓冲区，有什么好处？P310<br>1）形成所有块设备数据的统一集散地，操作系统的设计更方便更灵活<br>2）对块设备的文件操作运行效率更高</p>
<p>2、操作系统如何利用buffer_head中的 b_data，b_blocknr，b_dev，<br>b_uptodate，b_dirt，b_count，b_lock，b_wait管理缓冲块的？<br>buffer_head负责进程与缓冲块的数据交互，让数据在缓冲区中停留的时间尽可能长。P312页之后<br>b_data指向缓冲块，用于找到缓冲块的位置。</p>
<p>进程与缓冲区及缓冲区与硬盘之间都是以缓冲块为单位进行数据交互的，而b_blocknr，b_dev唯一标识一个块，用于保证数据交换的正确性。另外缓冲区中的数据被越多进程共享，效率就越高，因此要让缓冲区中的数据块停留的时间尽可能久，而这正是由b_blocknr，b_dev决定的，内核在hash表中搜索缓冲块时，只看设备号与块号，只要缓冲块与硬盘数据的绑定关系还在，就认定数据块仍停留在缓冲块中，就可以直接用。</p>
<p>b_uptodate与b_dirt，是为了解决缓冲块与数据块的数据正确性问题而存在的。b_uptodate针对进程方向，如果b_uptodate为1，说明缓冲块的数据和设备上的一样，可以支持进程共享缓冲块中的数据；如果b_uptodate为0，提醒内核缓冲块并没有用绑定的数据块中的数据更新，不支持进程共享该缓冲块。</p>
<p>b_dirt是针对硬盘方向的，b_dirt为1说明缓冲块的内容被进程方向的数据改写了，最终需要同步到硬盘上；b_dirt为0则说明不需要同步</p>
<p>b_count记录每个缓冲块有多少进程共享。 b_count大于0表明有进程在共享该缓冲块，当进程不需要共享缓冲块时，内核会解除该进程与缓冲块的关系，并将b_count数值减1，为0表明可以被当作新缓冲块来申请使用。</p>
<p>b_lock为1说明缓冲块正与硬盘交互，避免冲突，内核会拦截进程对该缓冲块的操作，以免发生错误，交互完成后，置0表明进程可以操作该缓冲块。</p>
<p>b_wait记录等待缓冲块的解锁而被挂起的进程，指向等待队列最先唤醒的task_struct。P364</p>
<p>3、操作系统如何处理多个进程等待同一个正在与硬盘交互的缓冲块？P125<br>调用wait_on_buffer-&gt;sleep_on，在sleep on函数中利用内核栈的temp和这个缓冲块的b_wait将等待的队列串成一个链表，形成缓冲块进程等待队列，等缓冲块交互完了，解锁了，从b-wait指向的那个task_struct开始唤醒。</p>
<p>4、getblk函数中，申请空闲缓冲块的标准就是b_count为0，而申请到之后，为什么在wait_on_buffer(bh)后又执行if（bh-&gt;b_count）来判断b_count是否为0？P115<br>因为wait_on_buffer的过程是在等sync_dev执行同步，此时b_count还没有置1，别的进程依然有机会用这个缓冲块，所以要判断一下是否在同步过程中被别的进程同样调用getblk被占用了。</p>
<p>5、b_dirt已经被置为1的缓冲块，同步前能够被进程继续读、写？给出代码证<br>据。P331<br>同步前能够被进程继续读、写</p>
<p>b_uptodate设置为1后，内核就可以支持进程共享该缓冲块的数据了，读写都可以，读操作不会改变缓冲块的内容，所以不影响数据，而执行写操作后，就改变了缓冲块的内容，就要将b_dirt标志设置为1。由于此前缓冲块中的数据已经用硬盘数据块更新了，所以后续的同步未被改写的部分不受影响，同步是不更改缓冲块中数据的，所以b_uptodate仍为1。即进程在b_dirt置为1时，仍能对缓冲区数据进行读写。</p>
<p>代码证据：代码P331</p>
<p>6、分析panic函数的源代码，根据你学过的操作系统知识，完整、准确的判断<br>panic()函数是当系统发现无法继续运行下去的故障时将调用它，会导致程序终止，然后由系统显示错误号。如果出现错误的函数不是进程0，那么就要进行数据同步，把缓冲区中的数据尽量同步到硬盘上。遵循了Linux尽量简明的原则。</p>
<p>改进panic函数：将死循环for(;;)；改进为跳转到内核进程（始终运行在0特权级的进程），让内核继续执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">代码： kernel/panic.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">void</span> <span class="title">panic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">         printk(<span class="string">"Kernel panic: %s\n\r"</span>,s);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (current == task[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">                   printk(<span class="string">"In swapper task - not syncing\n\r"</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">                   sys_sync();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(;;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）</p>
<ol>
<li><p>正常情况下，schedule()函数首先扫描任务数组。通过比较每个就绪（TASK_RUNNING）任务的运行时间递减滴答计数counter 的值来确定当前哪个进程运行的时间最少。哪一个的值大，就表示运行时间还不长，于是就选中该进程，最后调用switch_to()执行实际的进程切换操作</p>
</li>
<li><p>进程中有就绪进程，但所有就绪进程时间片都用完（c=0）</p>
</li>
</ol>
<p>如果此时所有处于TASK_RUNNING 状态进程的时间片都已经用完，系统就会根据每个进程的优先权值priority，对系统中所有进程（包括正在睡眠的进程）重新计算每个任务需要运行的时间片值counter。计算的公式是：</p>
<p>counter = counter + priority/2</p>
<p>然后 schdeule()函数重新扫描任务数组中所有处于TASK_RUNNING 状态，重复上述过程，直到选择出一个进程为止。最后调用switch_to()执行实际的进程切换操作。</p>
<ol start="3">
<li>所有进程都不是就绪的c=-1</li>
</ol>
<p>此时代码中的c=-1，next=0，跳出循环后，执行switch_to(0)，切换到进程0执行，因此所有进程都不是就绪的时候进程0执行。</p>
<p>8、wait_on_buffer函数中为什么不用if（）而是用while（）？P125<br>因为可能存在一种情况是，很多进程都在等待一个缓冲块。在缓冲块同步完毕，唤醒各等待进程到轮转到某一进程的过程中，很有可能此时的缓冲块又被其它进程所占用，并被加上了锁。此时如果用if()，则此进程会从之前被挂起的地方继续执行，不会再判断是否缓冲块已被占用而直接使用，就会出现错误；而如果用while()，则此进程会再次确认缓冲块是否已被占用，在确认未被占用后，才会使用，这样就不会发生之前那样的错误。</p>
<p>9、add_reques（）函数中有下列代码<br>    if (!(tmp = dev-&gt;current_request)) {<br>        dev-&gt;current_request = req;<br>        sti();<br>        (dev-&gt;request_fn)();<br>        return;<br>    }<br>其中的<br>    if (!(tmp = dev-&gt;current_request)) {<br>        dev-&gt;current_request = req;<br>是什么意思？<br>电梯算法完成后为什么没有执行do_hd_request函数？ P121<br>检查设备是否正忙，若目前该设备没有请求项，本次是唯一一个请求，之前无链表，则将该设备当前请求项指针直接指向该请求项，作为链表的表头。<br>因为电梯算法执行了说明不是第一次用了，在第一次用的时候已经给硬盘发送dev-&gt;request_fn读盘指令了。</p>
<p>p129-132<br>执行完电梯算法之后，此时已经在dev-&gt;current_request执行了do_hd_request，进入hd_out函数向硬盘发送读/写命令，当CPU收到硬盘中断信号时，去执行对应的_hd_interrput中断服务程序，调用了read_intr/write_intr函数，而它们中又调用了end_request(1)，end_request(1)函数中有CURRENT=CURRENT-&gt;next操作，此时CURRENT指向当前设备的请求项链的下一项，end_request函数返回之后，又调用了do_hd_request，所以会顺着当前设备的请求项链依次调用do_hd_request。</p>
<p>10、getblk（）函数中，两次调用wait_on_buffer（）函数，两次的意思一样<br>吗？P114,115<br>一样。 都是等待缓冲块解锁。</p>
<p>第一次调用是在， 已经找到一个比较合适的空闲缓冲块， 但是此块可能是加锁的， 于是等待</p>
<p>该缓冲块解锁。</p>
<p>第二次调用， 是找到一个缓冲块， 但是此块被修改过， 即是脏的， 还有其他进程在写或此块</p>
<p>等待把数据同步到硬盘上， 写完要加锁， 所以此处的调用仍然是等待缓冲块解锁。</p>
<p>11、getblk（）函数中<br>    do {<br>        if (tmp-&gt;b_count)<br>            continue;<br>        if (!bh || BADNESS(tmp)&lt;BADNESS(bh)) {<br>            bh = tmp;<br>            if (!BADNESS(tmp))<br>                break;<br>        }<br>/* and repeat until we find something good */<br>    } while ((tmp = tmp-&gt;b_next_free) != free_list);<br>说明什么情况下执行continue、break。P114<br>找空闲缓冲块，在tmp-&gt;bcount=1的时候continue,说明这个缓冲块不空闲，直接到下一个缓冲块，continue<br>break的情况是当BADNESS(tmp)=0说明b_dirt是0，b_lock也是0，没人正在用还干净，就用它了，不再找了，所以break</p>
<p>12、make_request（）函数<br>    if (req &lt; request) {<br>        if (rw_ahead) {<br>            unlock_buffer(bh);<br>            return;<br>        }<br>        sleep_on(&amp;wait_for_request);<br>        goto repeat;<br>其中的sleep_on(&amp;wait_for_request)是谁在等？等什么？P120下面<br>是当前进程在等请求项，req&lt;request说明从后面开始挪，都挪出去了也没找到空闲请求项，此时进程所需要的这个请求项就去了请求项等待队列，等这32个请求项中有空闲了，再醒。（请求项关联了设备和缓冲块）</p>
<p>13、bread（）函数代码中<br>    if (bh-&gt;b_uptodate)<br>        return bh;<br>    ll_rw_block(READ,bh);<br>    wait_on_buffer(bh);<br>    if (bh-&gt;b_uptodate)<br>        return bh;<br>为什么要做第二次if (bh-&gt;b_uptodate)判断？P119<br>第一次是判断新申请的这个缓冲区和设备同步不同步，如果同步的话就可以拿来直接用了，并且缓冲区解锁，睡眠醒来之后，要重新判断缓冲块是否有效，如果缓冲区中数据有效，则返回缓冲区头指针退出。否则释放该缓冲区返回 NULL,退出。在等待过程中，数据可能已经发生了改变，所以要第二次判断。</p>
<p>在睡眠等待缓冲块的锁被释放的过程中，可能有其他进程被唤醒去使用该缓冲块，等到该进程被唤醒时，b_uptodate可能已经被其他进程修改过了，需要再次进行判断。</p>
<p>14*、操作系统如何利用b_uptodate保证缓冲块数据的正确性？new_block (int dev)函数新申请一个缓冲块后，并没有读盘，b_uptodate却被置1，是否会引起数据混乱？详细分析理由。P329<br>新申请的缓冲块和硬盘里数据都是垃圾，垃圾不区分。</p>
<p>15*、do_hd_request()函数中dev的含义始终一样吗？P122<br>不是一样的。 dev/=5 之前表示当前硬盘的逻辑盘号。 这行代码之后表示的实际的物理设备号。</p>
<p>16*、read_intr（）函数中，下列代码是什么意思？为什么这样做？</p>
<pre><code>if (--CURRENT-&gt;nr_sectors) {

          do_hd = &amp;read_intr;

          return;} P130</code></pre><p>当前可能只是读完了设备的一个扇区，意思是如果设备没读完，继续挂钩子，回去读</p>
<p>17*、详细分析一个进程从创建、加载程序、执行、退出的全过程。P273</p>
<ol>
<li>创建进程，调用fork函数。<br>a) 准备阶段，为进程在task[64]找到空闲位置，即find_empty_process（）；<br>b) 为进程管理结构找到储存空间：task_struct和内核栈。<br>c) 父进程为子进程复制task_struct结构<br>d) 复制新进程的页表并设置其对应的页目录项<br>e) 分段和分页以及文件继承。<br>f)  建立新进程与全局描述符表（GDT）的关联<br>g) 将新进程设为就绪态</li>
<li>加载进程<br>a) 检查参数和外部环境变量和可执行文件<br>b) 释放进程的页表<br>c) 重新设置进程的程序代码段和数据段<br>d) 调整进程的task_struct</li>
<li>进程运行<br>a) 产生缺页中断并由操作系统响应<br>b) 为进程申请一个内存页面<br>c) 将程序代码加载到新分配的页面中<br>d) 将物理内存地址与线性地址空间对应起来<br>e) 不断通过缺页中断加载进程的全部内容<br>f)  运行时如果进程内存不足继续产生缺页中断，</li>
<li>进程退出<br>a) 进程先处理退出事务<br>b) 释放进程所占页面<br>c) 解除进程与文件有关的内容并给父进程发信号<br>d) 进程退出后执行进程调度</li>
</ol>
<p>18*、详细分析多个进程（无父子关系）共享一个可执行程序的完整过程。P299<br>假设有三个进程A、B、C，进程A先执行，之后是B最后是C，它们没有父子关系。A进程启动后会调用open函数打开该可执行文件，然后调用sys_read()函数读取文件内容,该函数最终会调用bread函数，该函数会分配缓冲块，进行设备到缓冲块的数据交换，因为此时为设备读入，时间较长，所以会给该缓冲块加锁，调用sleep_on函数，A进程被挂起，调用schedule()函数B进程开始执行。</p>
<p>B进程也首先执行open（）函数，虽然A和B打开的是相同的文件，但是彼此操作没有关系，所以B继承需要另外一套文件管理信息，通过open_namei()函数。B进程调用read函数，同样会调用bread（），由于此时内核检测到B进程需要读的数据已经进入缓冲区中，则直接返回，但是由于此时设备读没有完成，缓冲块以备加锁，所以B将因为等待而被系统挂起，之后调用schedule()函数。</p>
<p>C进程开始执行，但是同B一样，被系统挂起，调用schedule()函数，假设此时无其它进程，则系统0进程开始执行。</p>
<p>假设此时读操作完成，外设产生中断，中断服务程序开始工作。它给读取的文件缓冲区解锁并调用wake_up()函数，传递的参数是&amp;bh-&gt;b_wait,该函数首先将C唤醒，此后中断服务程序结束，开始进程调度，此时C就绪，C程序开始执行，首先将B进程设为就绪态。C执行结束或者C的时间片削减为0时，切换到B进程执行。进程B也在sleep_on()函数中，调用schedule函数进程进程切换，B最终回到sleep_on函数，进程B开始执行，首先将进程A设为就绪态，同理当B执行完或者时间片削减为0时，切换到A执行，此时A的内核栈中tmp对应NULL，不会再唤醒进程了。</p>
<p>另一种答案：</p>
<p>依次创建3个用户进程，每个进程都有自己的task。假设进程1先执行，需要压栈产生缺页中断，内核为其申请空闲物理页面，并映射到进程1的线性地址空间。这时产生时钟中断，轮到进程2执行，进程2也执行同样逻辑的程序。之后，又轮到进程3执行，也是压栈，并设置text。可见，三个进程虽程序相同，但数据独立，用TSS和LDT实现对进程的保护。</p>
<p>19*、缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？P264,268-270<br>① 缺页中断产生 P264</p>
<p>每一个页目录项或页表项的最后3位，标志着所管理的页面的属性，分别是U/S,R/W,P.如果和一个页面建立了映射关系，P标志就设置为1，如果没有建立映射关系，则P位为0。进程执行时，线性地址被MMU即系，如果解析出某个表项的P位为0，就说明没有对应页面，此时就会产生缺页中断。操作系统会调用_do_no_page为进程申请空闲页面，将程序加载到新分配的页面中，并建立页目录表-页表-页面的三级映射管理关系。</p>
<p>② 页写保护中断 P268-270</p>
<p>假设两个进程共享一个页面，该页面处于写保护状态即只读，此时若某一进程执行写操作，就会产生“页写保护”异常。操作系统会调用_do_wp_page，采用写时复制的策略，为该进程申请空闲页面，将该进程的页表指向新申请的页面，然后将原页表的数据复制到新页面中，同时将原页面的引用计数减1。该进程得到自己的页面，就可以执行写操作。</p>
<p>20*. 用图表示下面的几种情况，并从代码中找到证据：</p>
<p>A当进程获得第一个缓冲块的时候，hash表的状态</p>
<p>B经过一段时间的运行。已经有2000多个buffer_head挂到hash_table上时，hash表（包括所有的buffer_head）的整体运行状态。</p>
<p>C经过一段时间的运行，有的缓冲块已经没有进程使用了（空闲），这样的空闲缓冲块是否会从hash_table上脱钩？</p>
<p>D经过一段时间的运行，所有的buffer_head都挂到hash_table上了，这时，又有进程申请空闲缓冲块，将会发生什么？</p>
<p>A</p>
<p>getblk(int dev, int block) à get_hash_table(dev,block) -&gt; find_buffer(dev,block) -&gt; hash(dev, block)</p>
<p>哈希策略为：</p>
<pre><code>#define _hashfn(dev,block)(((unsigned)(dev block))%NR_HASH)

#define hash(dev,block) hash_table[_hashfn(dev, block)]</code></pre><p>此时，dev为0x300，block为0，NR_HASH为307，哈希结果为154，将此块插入哈希表中次位置后</p>
<p>B</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码路径 ：fs/buffer.c:   </span></span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">static inline void insert_into_queues(struct buffer_head * bh) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*put at end of free list */</span>   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bh</span>-&gt;</span>b_next_free= free_list;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bh</span>-&gt;</span><span class="function"><span class="title">b_prev_free</span>= free_list-&gt;</span>b_prev_free;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">free_list</span>-&gt;</span><span class="function"><span class="title">b_prev_free</span>-&gt;</span>b_next_free= bh;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">free_list</span>-&gt;</span>b_prev_free= bh;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*put the buffer in new hash-queue if it has a device */</span>   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bh</span>-&gt;</span>b_prev= NULL;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bh</span>-&gt;</span>b_next= NULL;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span> (!bh-&gt;</span>b_dev)        </span><br><span class="line"></span><br><span class="line">return;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bh</span>-&gt;</span><span class="function"><span class="title">b_next</span>= hash(bh-&gt;</span><span class="function"><span class="title">b_dev</span>,bh-&gt;</span>b_blocknr);   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">hash</span>(bh-&gt;</span><span class="function"><span class="title">b_dev</span>,bh-&gt;</span>b_blocknr)= bh;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">bh</span>-&gt;</span><span class="function"><span class="title">b_next</span>-&gt;</span>b_prev= bh</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>C</p>
<p>不会脱钩，会调用brelse()函数，其中if(!(buf-&gt;b_count–))，计数器减一。没有对该缓冲块执行remove操作。由于硬盘读写开销一般比内存大几个数量级，因此该空闲缓冲块若是能够再次被访问到，对提升性能是有益的。</p>
<p>D</p>
<p>进程顺着freelist找到没被占用的，未被上锁的干净的缓冲块后，将其引用计数置为1，然后从hash队列和空闲块链表中移除该bh，然后根据此新的设备号和块号重新插入空闲表和哈西队列新位置处，最终返回缓冲头指针。</p>
<p>Bh-&gt;b_count=1;</p>
<p>Bh-&gt;b_dirt=0;</p>
<p>Bh-&gt;b_uptodate=0;</p>
<p>Remove_from_queues(bh);</p>
<p>Bh-&gt;b_dev=dev;</p>
<p>Bh-&gt;b_blocknr=block;</p>
<p>Insert_into_queues(bh);</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/os/" rel="tag"># os</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/10/book/ouwei/" rel="next" title="《一个叫欧维的男人决定去死》">
                <i class="fa fa-chevron-left"></i> 《一个叫欧维的男人决定去死》
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/10/homework/拜占庭将军问题/" rel="prev" title="拜占庭将军问题">
                拜占庭将军问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="gitalk-container"></div>
    </div>

  




        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="Ning Ning">
            
              <p class="site-author-name" itemprop="name">Ning Ning</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-从开机加电到main函数执行之前"><span class="nav-number">1.</span> <span class="nav-text">第一章 从开机加电到main函数执行之前</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章：设备环境初始化及激活进程0"><span class="nav-number">2.</span> <span class="nav-text">第二章：设备环境初始化及激活进程0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章I-进程0创建进程1及调度"><span class="nav-number">3.</span> <span class="nav-text">第三章I:进程0创建进程1及调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章II-进程的执行"><span class="nav-number">4.</span> <span class="nav-text">第三章II:进程的执行</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ning Ning</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '6573f911da4349fc9ab6',
          clientSecret: '034400baf36061ab9814d24129908a063a59ca4a',
          repo: 'Wegnery219.github.io',
          owner: 'Wegnery219',
          admin: ['Wegnery219'],
          id:'gitalk_20191126161107',
          labels: 'gitalk'.split(',').filter(l => l),
          perPage: 10,
          pagerDirection: 'last',
          createIssueManually: false,
          distractionFreeMode: false
        })
        gitalk.render('gitalk-container')           
       </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
